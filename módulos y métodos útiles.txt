Módulos útiles del núcleo de NVDA
A lo largo de la vida del desarrollo de un complemento, te encontrarás con algunos módulos útiles del núcleo de NVDA que serían útiles en el código para tu complemento. Esta sección te los explica y también algunas funciones.
Nota: para lectores que sean creadores de scripts para otros lectores de pantalla, consultad el Apéndice D sobre las funciones equivalentes entre las herramientas de creación de scripts de lectores de pantalla.
Lista de módulos y métodos básicos útiles de NVDA
A continuación se enumeran los módulos disponibles del núcleo de NVDA y algunos métodos útiles que se encuentran en los módulos:
• Addon Handler (addonHandler.py): El módulo que implementa el subsistema de complementos. El método addonHandler.initTranslation() se utiliza para inicializar el soporte de internacionalización para tu complemento.
• API básica de NVDA (api.py): una colección de los métodos básicos utilizados en NVDA, como la obtención del foco y el navegador de objetos, ajustar el foco, etc. Algunas de las funciones más útiles son:
• api.getFocusObject(): recupera el control enfocado (devuelve el objeto con el foco).
• api.getNavigatorObject(): obtiene el navegador de objetos actual. Si NVDA está configurado para seguir al foco del sistema, el foco y el navegador de objetos serán lo mismo, de otro modo se devuelve un objeto diferente.
• api.getForegroundObject(): devuelve la ventana en primer plano de la aplicación actual (el padre de este objeto es la aplicación misma).
• Estos tienen un método correspondiente para establecer un objeto determinado como el foco o el navegador de objetos. Ten en cuenta que esto permite a NVDA consultar el foco o el navegador de objetos nuevo pero no cambia el foco actual del sistema.
• api.getDesktopObject(): devuelve la shell (objeto del nivel más alto).
• api.copyToClip(texto a copiar, notificar éxito o fallo opcionalmente): copia texto al portapapeles y, opcionalmente, pide a NVDA que avise al usuario sobre esta operación.
• Subsistema de módulos de aplicación (appModuleHandler.py, appModules): El subsistema encargado de manejar los módulos de aplicación (véase el capítulo sobre los módulos de aplicación para obtener más información).
• Soporte de ARIA (aria.py): implementa el soporte para aplicaciones de Internet enriquecidas accesibles (ARIA).
• Colección de objetos base (baseObject.py): contiene objetos base útiles tales como objetos scriptables (consulta el capítulo sobre objetos de NVDA y superposición de objetos para más información).
• Subsistema de entrada y salida braille (braille.py, brailleInput.py): controla la salida y la entrada braille de las pantallas braille, necesario para complementos de controladores de pantallas braille.
• Módulos integrados (builtin.py): permite el acceso a módulos integrados cuando se trabaja con complementos.
• Configuración (config): gestiona la configuración y los perfiles (los perfiles están disponibles en 2013.3 o posterior).
• Motores de reconocimiento de contenido (paquetes contentRecog): añade la capacidad de utilizar OCR y otros métodos para reconocer contenido en diversos escenarios. NVDA incorpora un motor de OCR para Windows 10.
• Colección de controles y estados (controlTypes.py): incluye diccionarios sobre los tipos de control (roles) y posibles estados.
• Eventos (eventHandler.py): maneja varios eventos como la optención del foco. Una función en particular es útil en los módulos de aplicación:
• eventHandler.requestEvents(evento a solicitar, id del proceso, nombre de clase de ventana del control): Permite a NVDA escuchar eventos específicos para ciertos controles mientras se utiliza otra aplicación.
• Puntos de extensión (extensionPoints): proporciona una forma de permitir que los complementos y otros módulos definan y respondan a acciones específicas como cambios de perfil, acciones en un complemento, etc. Se definen los siguientes puntos de extensión:
• extensionPoints.Action; notifica cuando algo ocurre, por ejemplo: el perfil cambia.
• extensionPoints.Decider: decide si procesar algo más, por ejemplo: procesar la entrada del teclado desde un sistema remoto.
• extensionPoints.Filter: modifica un texto determinado para su procesamiento posterior, por ejemplo, secuencias avanzadas de voz.
• Colección de Comandos globales (globalCommands.py): Una lista de las órdenes globales disponibles durante el uso de NVDA (véase la sección sobre el alcance de un script para más información).
• Subsistema de extensiones globales (globalPluginHandler.py): El módulo necesario para controlar las extensiones globales.
• GUI de NVDA (gui): Una colección de clases utilizadas por NVDA para mostrar sus mensajes de forma gráfica. Incluye la interfaz gráfica de usuario para el menú de NVDA, el administrador de complementos y otros.
• Utilidades de los puertos Hardware y gestión de la entrada y la salida (hwPortUtils.py, hwIo.py): Un conjunto de utilidades para la comunicación a través de los puertos serie de hardware y otros, útil durante el desarrollo de un complemento de controlador.
• Soporte para IAccessible (IAccessibleHandler, objetos IAccessible): Se utilizan para dar soporte a los controles Microsoft Active Accessibility (MSAA) / IAccessible.
• Gestión de entrada (inputCore.py): Gestiona la entrada del usuario.
• Soporte Java (JABHandler.py, objetos JAB): Una colección de los métodos utilizados para soportar el subsistema JAB (Java Access Bridge) utilizado por las aplicaciones Java.
• Entrada de teclado (keyboardHandler.py): Soporta la introducción de órdenes desde el teclado.
• Función de registro (logHandler.py): Permite a un módulo escribir registros para ser vistos por un desarrollador o por un usuario a través del visualizador de registro. Incluye la siguiente clase:
• logHandler.Log: la clase que implementa la utilidad de registro.
• Presentación de contenido matemático (paquetes de MathPress): permite a NVDA reconocer e interactuar con diversos contenidos matemáticos y lenguajes de marcado. NVDA incluye el paquete de soporte MathML y el soporte para Math Player, que viene incorporado en 2015.2 o posterior.
• Soporte de ratón (mouseHandler.py): Soporta órdenes de ratón.
• Colección de objetos de NVDA (NVDAObjects): Una colección de objetos o controles de NVDA que se utilizan en muchas aplicaciones y estándares como la UIA (User Interface Automation). Algunos objetos requieren que se realicen acciones especiales y éstas se especifican en el módulo de comportamientos del paquete de objetos NVDA. Entre los más comunes se incluyen:
• NVDAObjects.NVDAObject: la clase base para objetos de NVDA donde se definen eventos, propiedades, etcétera.
• NVDAObjects.behaviors: una colección de comportamientos para controles específicos, tales como editar campos con o sin detección de selección, terminales, consejos, globos de ayuda, una forma de simular órdenes de tabla en varios controles y otros.
• NVDAObjects.IAccessible: una colección de objetos MSAA/IAccessible, tales como la que funciona con vistas de listas SysListView32 y otros.
• NVDAObjects.JAB: una colección de clases utilizadas al interactuar con aplicaciones Java y Java Access Bridge.
• NVDAObjects.UIA: diversas clases para objetos impulsados por UI Automation. Desde 2016, también es el sitio de una colección de controles usados en el antiguo Microsoft Edge (no Chromium) y objetos promovidos por el motor de renderizado EdgeHTML.
• NVDAObjects.Window: ventanas genéricas y otros objetos personalizados como los que se encuentran en Microsoft Excel.
• Facilidad de revisión (review.py): ayuda a trabajar con el cursor de revisión.
• Soporte de Scripts (scriptHandler.py): Maneja scripts, métodos ejecutados debido a la pulsación de las órdenes de teclado y otras entradas.
• scriptHandler.script: un decorador que permite definir información sobre el script asociado mientras se define el propio script, incluyendo descripción (mensaje de ayuda de entrada), gesto o gestos (una orden o lista de órdenes), y la categoría del script.
• Salida de voz(speech): Controla la salida de voz.
• Soporte para controladores de Sintetizador (synthDriverHandler.py): Este es el módulo principal necesario para complementos de sintetizador de voz.
• Acceso al texto de los Widgets (textInfos): Permite el acceso al texto de widgets y documentos.
• Soporte de pantalla táctil (touchHandler.py): Proporciona soporte para la entrada de la pantalla táctil (sólo versiones instaladas).
• touchHandler.touchSupported(): indica si el sistema soporta interacción táctil.
• Salida de tonos (tones.py): Permite al usuario escuchar tonos. Se definió la siguiente función:
• tones.beep(tono en hercios, duración en milésimas de segundo, volumen del canal izquierdo, volumen del canal derecho): Reproduce un sonido de un tono específico durante un tiempo determinado. Los dos primeros argumentos son obligatorios, mientras que los otros dos son opcionales.
• Mensajes de la interfaz de usuario (ui.py): Incluye varias funciones para la salida de voz y/o braille, incluyendo:
• ui.message(mensaje que se verbaliza o se muestra en Braille, prioridad de la voz, mensaje Braille opcional): verbaliza o muestra en Braille el mensaje (una cadena encerrada entre comillas). Opcionalmente, se puede especificar la prioridad de la voz para interrumpir lo que verbaliza el sintetizador de voz cuando se anuncia el mensaje, así como emitir un mensaje diferente en las pantallas Braille.
• ui.browseableMessage(mensaje a ser mostrado, título, HTML o no): muestra algún texto y un título opcional en una ventana de navegador web. Si deseas utilizar el marcado HTML, define el argumento isHTML como True.
• Soporte UIA (UIAHandler.py, objetos UIA): Usado para soportar controles UIA (User Interface Automation) (Windows 7 y posteriores).
• Mmodos virtuales(virtualBuffers): Maneja documentos del modo virtual, tales como sitios web.
• Especificación de la versión de Windows y comprobaciones (winVersion.py): proporciona constantes que representan y comparan versiones de Windows.
• winVersion.getWinVer(): devuelve la versión actual de Windows (nombre de la versión, principal.menor.revisión, tipo de instalación, y service pack si lo hay). Estos datos se pueden comparar con otras versiones de Windows, por ejemplo para detectar una versión de Windows 10 concreta como la actualización de octubre de 2018. Ejemplo: winVersion.getWinVer() >= winVersion.WIN10_1809.
• Capas de la API de Windows: los siguientes módulos son capas delgadas de las bibliotecas de la API de Windows. Puedes utilizar los módulos siguientes o llamar a la API de Windows directamente a través de ctypes.windll.dllname (por ejemplo, ctypes.windll.user32):
• winKernel: abarca algunas constantes, estructuras y funciones de kernel32.dll que se encuentran comúnmente en NVDA.
• winUser: abarca las constantes, estructuras y funciones definidas en user32.dll que utiliza NVDA.